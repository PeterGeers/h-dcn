# Validation Utilities Guide

This guide explains how to use the new validation utilities in `auth_utils.py` for common role checking patterns during the role migration process.

## Overview

The validation utilities provide helper functions that make it easier to check user permissions and roles in a consistent way across all handlers. They support both the old legacy role structure and the new permission + region structure.

All Cognito Groups:
eu-west-1_OAT3oPCIm_Google: Autogenerated group for users who sign in using Google
Products_Export: Export products data permissions
Regio_Utrecht: Access to Utrecht region only
Events_Export: Export events data permissions
Communication_CRUD: Full communication management permissions
Regio_Limburg: Access to Limburg region only
Members_Export: Export members data permissions
Members_Read: Permission to read member data
Members_Status_Approve: Permission to approve member status changes
hdcnLeden: Basic H-DCN member role - access to personal data and webshop
Members_CRUD: Permission to create, read, update, delete member data
Regio_Groningen/Drenthe: Access to Groningen/Drenthe region only
Regio_Zuid-Holland: Access to Zuid-Holland region only
Communication_Export: Export communication data permissions
Events_CRUD: Permission to create, read, update, delete event data
Webshop_Management: Webshop management permissions - full control over webshop products and orders
Regio_Oost: Access to Oost region only
System_Logs_Read: Permission to read system logs and audit trails
Regio_Brabant/Zeeland: Access to Brabant/Zeeland region only
Regio_Friesland: Access to Friesland region only
System_User_Management: System user management permissions
Products_Read: Permission to read product data
Communication_Read: Read communication data permissions
Products_CRUD: Permission to create, read, update, delete product data
Regio_Duitsland: Access to Duitsland region only
Regio_All: Toegang tot alle regio's

## Available Utilities

### 1. Admin User Detection

```python
from auth_utils import is_admin_user

# Check if user has admin privileges
is_admin, admin_roles_found = is_admin_user(user_roles)

if is_admin:
    print(f"User is admin via: {admin_roles_found}")
    # Admin users have full access to everything
```

**Admin Roles**: `System_CRUD`, `System_User_Management`, `System_Logs_Read`

**Note**: The roles `hdcnAdmins`, `Webmaster`, and `System_CRUD_All` do NOT exist in the actual Cognito User Pool (verified 2026-01-08).

### 2. Basic Role Checking

```python
from auth_utils import has_any_role, has_all_roles

# Check if user has any of the specified roles
has_role, matching_roles = has_any_role(user_roles, ['Members_CRUD_All', 'Members_CRUD'])
if has_role:
    print(f"User has access via: {matching_roles}")

# Check if user has all required roles
has_all, missing_roles = has_all_roles(user_roles, ['Members_CRUD', 'Regio_All'])
if not has_all:
    print(f"User missing roles: {missing_roles}")
```

### 3. New Role Structure Validation

```python
from auth_utils import has_permission_and_region_access

# Check if user has both permission and region access
result = has_permission_and_region_access(user_roles, 'Members_CRUD')

if result['has_access']:
    print(f"Access granted: {result['message']}")
    print(f"Access type: {result['access_type']}")  # 'admin', 'legacy', 'new_structure'
else:
    print(f"Access denied: {result['message']}")
```

**Access Types**:

- `admin`: User has admin privileges
- `legacy`: User has legacy `_All` role
- `new_structure`: User has proper permission + region combination
- `denied`: User lacks required access

### 4. Regional Access Validation

```python
from auth_utils import can_access_resource_region

# Check if user can access data from a specific region
result = can_access_resource_region(user_roles, 'Noord-Holland')

if result['can_access']:
    print(f"Regional access: {result['message']}")
    print(f"User regions: {result['user_regions']}")
else:
    print(f"Regional access denied: {result['message']}")
```

### 5. CRUD Access Validation

```python
from auth_utils import validate_crud_access

# Check CRUD access for specific operations
result = validate_crud_access(user_roles, 'Members', 'create', 'Noord-Holland')

if result['has_access']:
    print(f"CRUD access granted: {result['message']}")
else:
    print(f"CRUD access denied: {result['message']}")
```

**Resource Types**: `Members`, `Events`, `Products`, `Communication`
**Operations**: `create`, `read`, `update`, `delete`, `export`

### 6. Quick Role Check Utility

```python
from auth_utils import quick_role_check

# Quick checks for common patterns
has_access, message = quick_role_check(user_roles, 'admin')
has_access, message = quick_role_check(user_roles, 'any_role', roles=['Members_CRUD_All'])
has_access, message = quick_role_check(user_roles, 'permission', permission='Members_CRUD')
has_access, message = quick_role_check(user_roles, 'crud', resource='Members', operation='read')
has_access, message = quick_role_check(user_roles, 'region', region='Noord-Holland')

print(f"Access: {has_access}, Message: {message}")
```

### 7. Role Validator Factory

```python
from auth_utils import create_role_validator

# Create reusable validators for common patterns

# Legacy role validator
legacy_validator = create_role_validator(['Members_CRUD_All', 'hdcnAdmins'])
has_access, details = legacy_validator(user_roles)

# New structure validator
new_validator = create_role_validator({
    'permission': 'Members_CRUD',
    'regions': ['Noord-Holland', 'Zuid-Holland']
})
has_access, details = new_validator(user_roles)
```

### 8. Comprehensive Permissions Summary

```python
from auth_utils import get_user_permissions_summary

# Get complete analysis of user's permissions
summary = get_user_permissions_summary(user_roles)

print(f"Is admin: {summary['is_admin']}")
print(f"Role structure valid: {summary['summary']['has_valid_structure']}")
print(f"Migration needed: {summary['summary']['migration_needed']}")
print(f"Access level: {summary['summary']['access_level']}")

# Check specific resource permissions
members_permissions = summary['resource_permissions']['Members']
print(f"Can create members: {members_permissions['create']['has_access']}")
print(f"Can export members: {members_permissions['export']['has_access']}")
```

### 9. Role Structure Analysis

```python
from auth_utils import validate_user_has_new_role_structure

# Analyze user's role structure
result = validate_user_has_new_role_structure(user_roles)

print(f"Has new structure: {result['has_new_structure']}")
print(f"Permission roles: {result['permission_roles']}")
print(f"Region roles: {result['region_roles']}")
print(f"Legacy roles: {result['legacy_roles']}")
print(f"Message: {result['validation_message']}")
```

## Migration Patterns

### Pattern 1: Simple Role Check Migration

**Before (Legacy)**:

```python
# Old pattern - checking for specific roles
if any(role in user_roles for role in ['Members_CRUD_All', 'hdcnAdmins']):
    # User has access
    pass
```

**After (Using Utilities)**:

```python
# New pattern - using validation utilities
has_access, message = quick_role_check(user_roles, 'any_role',
                                     roles=['Members_CRUD_All', 'hdcnAdmins'])
if has_access:
    # User has access
    pass
```

### Pattern 2: Permission + Region Migration

**Before (Legacy)**:

```python
# Old pattern - only checking legacy roles
if 'Members_CRUD_All' in user_roles:
    # User has access
    pass
```

**After (Using Utilities)**:

```python
# New pattern - supports both legacy and new structure
result = has_permission_and_region_access(user_roles, 'Members_CRUD')
if result['has_access']:
    # User has access via legacy, new structure, or admin
    print(f"Access type: {result['access_type']}")
```

### Pattern 3: Regional Data Access

**Before (Legacy)**:

```python
# Old pattern - no regional filtering
# All users with Members_CRUD_All could access all data
```

**After (Using Utilities)**:

```python
# New pattern - with regional filtering
result = validate_crud_access(user_roles, 'Members', 'read', resource_region)
if result['has_access']:
    # User can access this specific regional data
    pass
```

### Pattern 4: Handler Migration Template

```python
# Complete handler migration pattern
from auth_utils import (
    extract_user_credentials,
    has_permission_and_region_access,
    create_success_response,
    create_error_response
)

def lambda_handler(event, context):
    # Extract credentials
    user_email, user_roles, auth_error = extract_user_credentials(event)
    if auth_error:
        return auth_error

    # Validate permissions using utilities
    result = has_permission_and_region_access(user_roles, 'Members_CRUD')
    if not result['has_access']:
        return create_error_response(403, result['message'])

    # Log migration info if using legacy roles
    if result['access_type'] == 'legacy':
        print(f"MIGRATION_NEEDED: Handler using legacy roles: {result['permission_roles']}")

    # Handler logic here...
    return create_success_response({'message': 'Success'})
```

## Best Practices

1. **Use the utilities consistently** across all handlers for uniform behavior
2. **Log migration information** when legacy roles are detected
3. **Test both legacy and new role structures** during the transition period
4. **Use `quick_role_check()`** for simple patterns to reduce code complexity
5. **Use `has_permission_and_region_access()`** for the new role structure validation
6. **Always check regional access** when dealing with member data
7. **Use the validator factory** for reusable validation patterns

## Testing

Run the test suite to verify the utilities work correctly:

```bash
python backend/test_validation_utilities.py
```

The test covers all utility functions and common usage patterns.

## Migration Support

These utilities are designed to support the gradual migration from legacy `_All` roles to the new permission + region structure:

- **Backward Compatible**: All utilities support legacy roles during transition
- **Migration Detection**: Utilities can detect and log when legacy roles are used
- **Flexible**: Support both old and new patterns in the same codebase
- **Consistent**: Provide uniform behavior across all handlers

Use these utilities to make the role migration process smoother and more reliable.
