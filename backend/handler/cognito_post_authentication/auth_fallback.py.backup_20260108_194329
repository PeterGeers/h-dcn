"""
Fallback authentication module that can be copied to individual handler directories
This ensures consistent auth behavior even when shared modules aren't available
"""

import json
import base64
from datetime import datetime


def extract_user_credentials(event):
    """Extract user credentials with enhanced groups support"""
    try:
        auth_header = event.get('headers', {}).get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return None, None, {
                'statusCode': 401,
                'headers': cors_headers(),
                'body': json.dumps({'error': 'Authorization header required'})
            }
        
        jwt_token = auth_header.replace('Bearer ', '')
        parts = jwt_token.split('.')
        if len(parts) != 3:
            return None, None, {
                'statusCode': 401,
                'headers': cors_headers(),
                'body': json.dumps({'error': 'Invalid JWT token format'})
            }
        
        payload_encoded = parts[1]
        payload_encoded += '=' * (4 - len(payload_encoded) % 4)
        payload_decoded = base64.urlsafe_b64decode(payload_encoded)
        payload = json.loads(payload_decoded)
        
        user_email = payload.get('email') or payload.get('username')
        if not user_email:
            return None, None, {
                'statusCode': 401,
                'headers': cors_headers(),
                'body': json.dumps({'error': 'User email not found in token'})
            }
        
        # Check for enhanced groups from frontend
        enhanced_groups_header = event.get('headers', {}).get('X-Enhanced-Groups')
        if enhanced_groups_header:
            try:
                enhanced_groups = json.loads(enhanced_groups_header)
                if isinstance(enhanced_groups, list):
                    print(f"üîç Using enhanced groups: {enhanced_groups} for {user_email}")
                    return user_email, enhanced_groups, None
            except json.JSONDecodeError:
                pass
        
        user_roles = payload.get('cognito:groups', [])
        print(f"üîç Using JWT groups: {user_roles} for {user_email}")
        return user_email, user_roles, None
        
    except Exception as e:
        print(f"Auth error: {str(e)}")
        return None, None, {
            'statusCode': 401,
            'headers': cors_headers(),
            'body': json.dumps({'error': 'Invalid authorization token'})
        }


def validate_permissions(user_roles, required_permissions, user_email=None, resource_context=None):
    """Validate user permissions with new role structure support"""
    # Updated admin roles - removed old _All roles, added new structure roles
    admin_roles = [
        'hdcnAdmins', 'System_CRUD_All', 'System_CRUD', 'Webmaster', 
        'System_User_Management', 'System_Logs_Read',
        'National_Chairman', 'National_Secretary'
    ]
    
    # Check for admin access
    if any(role in admin_roles for role in user_roles):
        return True, None
    
    # Check for legacy _All roles (backward compatibility during migration)
    legacy_all_roles = [role for role in user_roles if role.endswith('_All')]
    if legacy_all_roles:
        print(f"‚ö†Ô∏è MIGRATION_NOTICE: User {user_email} using legacy roles: {legacy_all_roles}")
        return True, None
    
    # For new role structure, check if user has both permission and region roles
    permission_roles = [role for role in user_roles 
                       if any(role.startswith(prefix) for prefix in ['Members_', 'Events_', 'Products_', 'Communication_'])
                       and not role.endswith('_All')]
    region_roles = [role for role in user_roles if role.startswith('Regio_')]
    
    # New role structure requires both permission and region roles (except for system roles)
    system_roles = ['System_CRUD', 'System_User_Management', 'System_Logs_Read']
    has_system_role = any(role in user_roles for role in system_roles)
    
    if permission_roles and (region_roles or has_system_role):
        return True, None
    
    # For non-admin users without proper role structure, deny access
    return False, {
        'statusCode': 403,
        'headers': cors_headers(),
        'body': json.dumps({
            'error': 'Access denied: Insufficient permissions',
            'required_permissions': required_permissions,
            'user_roles': user_roles,
            'migration_note': 'New role structure requires both permission role (e.g., Members_CRUD) and region role (e.g., Regio_All)'
        })
    }


def cors_headers():
    """Standard CORS headers"""
    return {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type, Authorization, X-Enhanced-Groups"
    }


def handle_options_request():
    """Handle OPTIONS requests"""
    return {
        'statusCode': 200,
        'headers': cors_headers(),
        'body': ''
    }


def log_successful_access(user_email, user_roles, operation, resource_context=None):
    """Log successful access"""
    print(f"ACCESS: {user_email} (roles: {user_roles}) performed {operation}")
    if resource_context:
        print(f"CONTEXT: {resource_context}")


def create_error_response(status_code, error_message, details=None):
    """Create standardized error response"""
    body = {'error': error_message}
    if details:
        body.update(details)
    return {
        'statusCode': status_code,
        'headers': cors_headers(),
        'body': json.dumps(body)
    }


def create_success_response(data, status_code=200):
    """Create standardized success response"""
    return {
        'statusCode': status_code,
        'headers': cors_headers(),
        'body': json.dumps(data)
    }


def require_auth_and_permissions(required_permissions):
    """
    Decorator function to add authentication and permission checking to any handler
    Usage: @require_auth_and_permissions(['events_update'])
    """
    def decorator(handler_func):
        def wrapper(event, context):
            # Handle OPTIONS request
            if event.get('httpMethod') == 'OPTIONS':
                return handle_options_request()
            
            # Extract credentials
            user_email, user_roles, auth_error = extract_user_credentials(event)
            if auth_error:
                return auth_error
            
            # Validate permissions
            has_permission, permission_error = validate_permissions(
                user_roles, required_permissions, user_email
            )
            if not has_permission:
                return permission_error
            
            # Log access
            log_successful_access(user_email, user_roles, handler_func.__name__)
            
            # Call original handler with auth info
            return handler_func(event, context, user_email, user_roles)
        
        return wrapper
    return decorator